### **1. 시스템 개요**

- **핵심 철학:** 이 시스템은 정적인 규칙에 따라 움직이는 단순한 봇이 아닙니다. 자신의 투자 결정을 기록하고, 그 결과를 주기적으로 복기하며, 실패로부터 배워 스스로의 핵심 로직(의사결정 프롬프트)을 수정해나가는 **학습하는 유기체**입니다. AI는 자율적인 '펀드매니저' 역할을, 인간은 시스템의 학습 과정을 감독하고 필요시 개입하는 '운용 총괄(Overseer)' 역할을 맡습니다.
- **주요 구성 요소:**
  1. **거래 데이터베이스:** 모든 활동과 학습의 근간이 되는 중앙 기억 장치.
  2. **운영 그래프 (Trading Graph):** 실시간으로 시장에 대응하여 포트폴리오를 관리하고 매매를 실행하는 '실행부'. (매 시간 또는 매일 실행)
  3. **성찰 및 개선 그래프 (Reflection & Improvement Graph):** 기록된 데이터를 분석하여 운영 그래프의 두뇌를 업그레이드하는 '학습부'. (매주 또는 매월 실행)
- **작동 방식:**`운영 그래프`가 거래를 실행하고 데이터베이스에 상세히 기록합니다. → 주기적으로 `성찰 그래프`가 데이터베이스의 기록을 분석하여 성공과 실패의 패턴을 학습합니다. → 학습된 교훈을 바탕으로 `운영 그래프`의 핵심 의사결정 로직을 자동으로 업데이트합니다. → 더 똑똑해진 `운영 그래프`가 다음 거래를 수행합니다. 이 순환이 반복되며 시스템은 점차 진화합니다.

---

### **2. 핵심 인프라: 거래 데이터베이스 (The Central Memory)**

모든 학습의 전제조건은 양질의 데이터입니다. 각 거래가 완료될 때마다 다음 정보가 하나의 레코드(Record)로 저장되어야 합니다.

| 필드 명                  | 데이터 타입 | 설명                                                               |
| ------------------------ | ----------- | ------------------------------------------------------------------ |
| `trade_id`               | Integer     | 거래 고유 식별자 (Primary Key)                                     |
| `timestamp`              | Datetime    | 거래가 실행된 정확한 시간                                          |
| `ticker`                 | String      | 종목 코드 (예: '005930')                                           |
| `action`                 | String      | 'BUY' 또는 'SELL'                                                  |
| `quantity`               | Integer     | 거래 수량                                                          |
| `price`                  | Float       | 평균 체결 단가                                                     |
| **`justification_text`** | Text        | **(핵심)** 이 거래를 결정한 AI의 상세한 논리적 근거                |
| **`market_snapshot`**    | JSON/Text   | 거래 당시의 시장 상황 (예: 코스피 지수, VIX, 주요 뉴스 헤드라인)   |
| `portfolio_before`       | JSON/Text   | 거래 직전의 전체 포트폴리오 상태                                   |
| `pnl_7_days`             | Float       | **(결과)** 거래 7일 후의 해당 포지션 수익률 (주기적으로 업데이트)  |
| `pnl_30_days`            | Float       | **(결과)** 거래 30일 후의 해당 포지션 수익률 (주기적으로 업데이트) |

---

### **3. 제1 루프: 운영 그래프 (The Trading Graph)**

실제 시장에 대응하여 자산을 운용하는 실시간 실행 엔진입니다.

- **[상태(State) 객체]:** `portfolio_status`, `market_analysis`, `trade_plan`, `justification_text`, `execution_results` 등의 정보를 담아 노드 간에 전달합니다.
- **노드(Node) 상세 워크플로우:**
  1. **`[노드 1: 포트폴리오 진단]`**
     - **Input:** 증권사 API Key
     - **Action:** 현재 보유 종목, 수량, 평균 단가, 현금 예수금 등 계좌의 모든 정보를 API를 통해 조회합니다.
     - **Output:** 조회된 정보를 `State`의 `portfolio_status`에 업데이트합니다.
  2. **`[노드 2: 시장 분석 및 기회/위험 탐색]`**
     - **Input:** `State`의 `portfolio_status`
     - **Action:** 현재 보유 자산 및 시장 전체 상황을 분석합니다. (기술적 지표, 거시 경제 지표, 뉴스 등)
     - **Output:** 분석 결과를 `State`의 `market_analysis`에 업데이트합니다.
  3. **`[노드 3: 거래 계획 수립 (The Brain)]`**
     - **Input:** `State`의 `portfolio_status`, `market_analysis`
     - **Action:** **핵심 의사결정 프롬프트**를 기반으로 LLM을 호출합니다. 이 프롬프트에는 기본적인 투자 철학과 함께, **성찰 루프에 의해 지속적으로 업데이트되는 동적인 행동 규칙들**이 포함되어 있습니다.
     - **Output:** 구체적인 매매 계획(`trade_plan`)과 그 결정에 대한 상세한 근거(`justification_text`)를 생성하여 `State`에 저장합니다.
  4. **`[노드 4: 최종 리스크 점검]`**
     - **Input:** `State`의 `trade_plan`, `portfolio_status`
     - **Action:** 수립된 계획이 현금 초과, 수량 오류 등 치명적인 오류를 포함하고 있는지 최종 검증합니다.
     - **Output:** **조건부 엣지(Conditional Edge)**를 통해, 검증 통과 시 `주문 실행`으로, 실패 시 `기록 및 보고`로 즉시 분기합니다.
  5. **`[노드 5: 주문 실행]`**
     - **Input:** `State`의 `trade_plan`
     - **Action:** 증권사 API를 통해 실제 매수/매도 주문을 실행하고 체결 결과를 기다립니다.
     - **Output:** 체결 내역을 `State`의 `execution_results`에 업데이트합니다.
  6. **`[노드 6: 기록 및 보고]`**
     - **Input:** `State` 전체
     - **Action:**
       1. `State`의 모든 정보를 조합하여 **거래 데이터베이스**에 하나의 완전한 레코드로 저장합니다.
       2. 관리자에게 거래 내역과 결정 근거를 요약하여 슬랙/이메일로 보고합니다.
     - **Output:** 그래프 실행 종료.

---

### **4. 제2 루프: 성찰 및 개선 그래프 (The Reflection & Improvement Graph)**

주기적으로(예: 매주 일요일) 실행되어 과거를 통해 시스템을 성장시키는 학습 엔진입니다.

- **[상태(State) 객체]:** `weekly_report`, `worst_trades_data`, `improvement_insights`, `new_strategy_rule` 등의 정보를 담습니다.
- **노드(Node) 상세 워크플로우:**
  1. **`[노드 M1: 성과 데이터 집계]`**
     - **Input:** 거래 데이터베이스 연결 정보
     - **Action:** 지난주 거래 기록을 모두 조회하여 총 수익률, 승률, Best/Worst 거래 등을 포함한 '주간 성과 보고서'를 생성합니다. 특히 손실이 컸던 거래들의 모든 데이터(`justification_text`, `market_snapshot` 포함)를 상세히 추출합니다.
     - **Output:** `State`에 `weekly_report`와 `worst_trades_data`를 저장합니다.
  2. **`[노드 M2: 성공/실패 요인 분석 엔진]`**
     - **Input:** `State`의 `weekly_report`, `worst_trades_data`
     - **Action:** LLM에게 손실 거래들의 데이터와 결정 근거를 제시하며, 실패의 공통적인 원인이나 잘못된 패턴을 심층적으로 분석하도록 지시합니다. (예: "과도한 자신감으로 특정 지표를 맹신한 경향을 분석하라.")
     - **Output:** 분석 결과를 바탕으로 "앞으로 개선해야 할 점"에 대한 구체적인 '개선 인사이트'를 `State`의 `improvement_insights`에 저장합니다.
  3. **`[노드 M3: 전략 규칙 생성]`**
     - **Input:** `State`의 `improvement_insights`
     - **Action:** 추상적인 '개선 인사이트'를, 운영 그래프가 직접 사용할 수 있는 명시적이고 구체적인 **'행동 규칙' 텍스트**로 변환합니다. (예: "VIX 지수가 25 이상일 때는 신규 매수 비중을 총자산의 5% 이내로 제한한다.")
     - **Output:** 생성된 규칙 텍스트를 `State`의 `new_strategy_rule`에 저장합니다.
  4. **`[노드 M4: 시스템 로직 자동 업데이트]`**
     - **Input:** `State`의 `new_strategy_rule`
     - **Action:** `운영 그래프`의 `노드 3`이 사용하는 **핵심 의사결정 프롬프트 파일**을 프로그램적으로 읽어옵니다. → 프롬프트 내의 '투자 원칙' 섹션에 새로운 규칙을 추가합니다. → 업데이트된 프롬프트 파일을 저장합니다. (Git과 연동하여 변경 사항을 커밋하면 더욱 안전합니다.)
     - **Output:** 관리자에게 이번 주 학습 결과와 새롭게 추가된 규칙을 보고하며 그래프를 종료합니다.
